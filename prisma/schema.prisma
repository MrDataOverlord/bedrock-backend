generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =======================
// Core
// =======================

// Renamed from "Device" to avoid conflict with HWID Device model below
// This appears to be for mobile push notifications
model MobileDevice {
  id        String   @id @default(cuid())
  deviceId  String
  platform  String
  pushToken String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String?
  totpSecret    String?
  isAdmin       Boolean  @default(false) 
  createdAt     DateTime @default(now())
  
  // HWID Device Management System
  devices           AuthorizedDevice[]
  deviceResetTokens DeviceResetToken?

  ownedOrgs      Org[]
  memberships    Member[]
  passwordTokens PasswordToken[]
  
  // Premium notification relations
  notificationSettings NotificationSettings?
  notificationTriggers NotificationTrigger[]
}

model Org {
  id               String   @id @default(cuid())
  ownerUserId      String?          // optional so webhooks can create org first
  name             String   @default("My Org")
  createdAt        DateTime @default(now())

  // Required by server.js to link Stripe customer to this org
  stripeCustomerId String?  @unique

  owner         User?          @relation(fields: [ownerUserId], references: [id])
  members       Member[]
  subscriptions Subscription[]

  @@index([ownerUserId])
}

model Member {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  role      String   @default("owner")
  createdAt DateTime @default(now())

  org  Org  @relation(fields: [orgId], references: [id])
  user User @relation(fields: [userId], references: [id])

  // used by server.js upsert(where: { orgId_userId: { ... } })
  @@unique([orgId, userId], name: "orgId_userId")
  @@index([orgId])
  @@index([userId])
}

// =======================
// Password / Registration
// =======================

model PasswordToken {
  id        String    @id @default(cuid())
  userId    String
  purpose   String      // 'register' | 'reset'
  tokenHash String      @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime    @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

// ============================================================================
// Device Management System - HWID-based Authorization
// ============================================================================

// HWID Device tracking for premium feature authorization
// Renamed from "Device" to "AuthorizedDevice" to avoid conflict
model AuthorizedDevice {
  id           String   @id @default(cuid())
  userId       String
  deviceId     String   // HWID hash
  deviceName   String   // User-friendly name
  appType      String   // "commander" | "server-manager"
  platform     String   // "Windows" | "Linux"
  lastSeenAt   DateTime @default(now())
  registeredAt DateTime @default(now())
  active       Boolean  @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId, appType]) // One HWID per app type per user
  @@index([userId])
  @@index([deviceId])
  @@index([userId, appType])
}

// Device reset token system (1 per month)
model DeviceResetToken {
  id        String   @id @default(cuid())
  userId    String
  tokensRemaining Int   @default(2) // Start with 2 tokens
  lastResetAt     DateTime? // When they last used a reset token
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@index([userId])
}

// Audit log for device changes
model DeviceAuditLog {
  id        String   @id @default(cuid())
  userId    String
  deviceId  String
  appType   String
  action    String   // "registered" | "unregistered" | "reset" | "rejected"
  reason    String?  // Additional context
  ipAddress String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([deviceId])
  @@index([createdAt])
}

// =======================
// Billing
// =======================

model Subscription {
  id               String    @id                // we store "stripe_<subId>"
  orgId            String
  provider         String                         // "stripe"
  status           String
  currentPeriodEnd DateTime?
  customerId       String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  org Org @relation(fields: [orgId], references: [id])

  @@index([orgId])
  @@index([provider])
}

// =======================
// Premium Features - Server Side Validation
// =======================

model NotificationSettings {
  id          String   @id @default(cuid())
  userId      String   @unique
  soundEnabled Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user  User @relation(fields: [userId], references: [id], onDelete: Cascade)
  rules NotificationRule[]

  @@index([userId])
}

model NotificationRule {
  id        String   @id @default(cuid())
  settingsId String
  name      String
  type      String   @default("contains") // "contains" or "regex"
  pattern   String
  soundFile String   @default("default.wav")
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  settings NotificationSettings @relation(fields: [settingsId], references: [id], onDelete: Cascade)

  @@index([settingsId])
}

model NotificationTrigger {
  id          String   @id @default(cuid())
  userId      String
  ruleName    String
  triggeredAt DateTime @default(now())
  lineLength  Int      @default(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([triggeredAt])
}
